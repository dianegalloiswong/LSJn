
\documentclass[18pt]{beamer}
\usepackage{beamerthemesplit}
\usetheme[secheader]
{Madrid}
%\usetheme{Warsaw}
\usecolortheme{dolphin}

\usepackage{graphicx}
\usepackage{array} %nouveau langages formels
%\usepackage{landscape}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[frenchb]{babel}
\usepackage{amstext}
\usepackage[latin1]{inputenc}
%\usepackage[OT1]{fontenc}
\usepackage{pgf,tikz}
\usetikzlibrary{arrows}
\usepackage{fancyvrb}
%\usepackage{lipsum}
\usepackage{xcolor}



\newcounter{moncompteur}
\newtheorem{q}[moncompteur]{\textbf{Question}}{}
\newtheorem{prop}[moncompteur]{\textbf{Proposition}}{}
\newtheorem{df}[moncompteur]{\textbf{Définition}}{}
\newtheorem{rem}[moncompteur]{\textbf{Remarque}}{}
\newtheorem{theo}[moncompteur]{\textbf{Théorème}}{}
\newtheorem{conj}[moncompteur]{\textbf{Conjecture}}{}
\newtheorem{cor}[moncompteur]{\textbf{Corollaire}}{}
\newtheorem{lm}[moncompteur]{\textbf{Lemme}}{}
%\newtheorem{nota}[moncompteur]{\textbf{Notation}}{}
%\newtheorem{conv}[moncompteur]{\textbf{Convention}}{}
\newtheorem{exa}[moncompteur]{\textbf{Exemple}}{}
\newtheorem{exas}[moncompteur]{\textbf{Exemples}}{}
\newtheorem{ex}[moncompteur]{\textbf{Exercice}}{}
%\newtheorem{app}[moncompteur]{\textbf{Application}}{}
%\newtheorem{prog}[moncompteur]{\textbf{Algorithme}}{}
%\newtheorem{hyp}[moncompteur]{\textbf{Hypothèse}}{}
\newenvironment{dem}{\noindent\textbf{Preuve}\\}{\flushright$\blacksquare$\\}

\newtheorem{cadre}{}{}



%mémoire et stage
\usepackage{bussproofs} %arbres de preuve
	\EnableBpAbbreviations

\newtheorem{dfprop}[moncompteur]{\textbf{Définition / Proposition}}{}

\newcommand{\s}{\sigma}


%mémoire
\newcommand{\revAnd}{\rotatebox[origin=c]{180}{\&}}
\newcommand{\Ccal}{\mathcal{C}}
\newcommand{\Dcal}{\mathcal{D}}
\newcommand{\1}{\boldsymbol{1}}
\newcommand{\0}{\boldsymbol{0}}
\newcommand{\CProofs}{
%?\mathcal{C}?
\mathcal{CP}
}
%



\newcommand{\idees}[1]{
\textsf{(#1)}
}



%stage
\newcommand{\LK}{$\mathbf{LK}$}
\newcommand{\LJ}{$\mathbf{LJ}$}
\newcommand{\LJT}{$\mathbf{LJT}$}
\newcommand{\LSJ}{$\mathbf{LSJ}$}
\newcommand{\LSJn}{$\mathbf{LSJ\boldsymbol\ell}$}

%\newcommand{\T}{$\mathbf{T}$}
\newcommand{\T}{$\boldsymbol{T}$}
\newcommand{\M}{$\boldsymbol{M}$}

\newcommand{\Sig}{\mathfrak S}
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\Gp}{\Gamma}
\newcommand{\Dp}{\Delta}
\newcommand{\Gt}{\widetilde\Gamma}
\newcommand{\Dt}{\widetilde\Delta}
\newcommand{\ClG}{\widetilde\Gamma}
\newcommand{\ClD}{\widetilde\Delta}


\newcommand{\imp}{\to\negthickspace}

\newcommand{\surj}{
%\mathrm{surj}
\boldsymbol
\Phi
}
%\newcommand{\To}{\Rightarrow}
\newcommand{\To}{\vdash}
\newcommand{\forget}{\mathsf{forget}}



\newcommand{\autour}[5]{
%^{#2}_{#3}#1^{#4}_{#5}
%\scriptsize{#2}#1_{_{#4}}\scriptsize{#3}
%^{\mathbf{#2}}#1^{#3}_{_{#4}}
^{\mathbf{#2}\;}#1^{\;\mathit{#3}}_{_{#4}}
}




%%%%



\newcommand{\R}{\mathbb{R}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\U}{\mathbb{U}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\card}{\mathrm{card}}


%automates d'arbres
\newcommand{\F}{\mathcal{F}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\TFX}{T(\F,\X)}
\newcommand{\TF}{T(\F)}
\newcommand{\TFp}{T(\F')}
\newcommand{\A}{\mathcal{A}}
%\renewcommand{\L}{\mathcal{L}}
\newcommand{\epsi}{\varepsilon}

\setbeamertemplate{navigation symbols}{%
%\insertslidenavigationsymbol
%\insertframenavigationsymbol
%\insertsubsectionnavigationsymbol
%\insertsectionnavigationsymbol
%\insertdocnavigationsymbol
%\insertbackfindforwardnavigationsymbol
}






%ÀÉÈ

\begin{document}


\AtBeginSection[]
{
 \begin{frame}<beamer>
 \tableofcontents[currentsection]
 \end{frame}
}


\title{Calcul des séquents}
\author{Diane Gallois-Wong}
%\institute{TIPE}
\date{2014}
\frame{\titlepage}



\frame{
\frametitle{Introduction}

%Automates d'arbres introduits pour la vérification de circuits logiques.
% 
%Vers 1960 : Church, Trakhtenbrot, B\"uchi, Rabin, Doner, Thatcher, ...
%    
%\
%    
%Applications : interprétation abstraite, démonstration automatique de théorèmes et vérification de programmes, bases de données, langages XML Schema, ...


}\frame{
\tableofcontents

}\frame{

Logiques propositionnelles

\

Formule :




}
%\section{Introduction au calcul des séquents}
%\subsection{Le calcul \LK\ associé à la logique classique}


\frame{
\frametitle{Les séquents}

Chaque calcul des séquents a sa propre définition d'un \emph{séquent}.

\

\begin{df}
%Un \textbf{\emph{séquent}} de \LK\ consiste en deux listes de formules $\G$ (les ``hypothèses'') et $\D$ (les ``conclusions'') ; on le note $\G \vdash \D$. On appellera \emph{séquent classique} un tel séquent.
Un \textbf{\emph{séquent}} de \LK\ consiste en deux listes de formules $\G$ et $\D$.

On le note $\G \vdash \D$.

\end{df}


%Séquent : $\G \To \D$ \qquad où $\G$, $\D$ listes de formules

\

\

Formules de $\G$ : ``hypothèses'' \qquad Formules de $\D$ : ``conclusions''

\

Un séquent $\G \To \D$ correspond à la formule $\left(\bigwedge_{G\in\G}G\right)\to\left(\bigvee_{D\in\D}D\right)$ en logique classique.



}
\frame{
\frametitle{Les règles}

Règles de la forme :
	\AXC{\emph{prémisses}}
	\RightLabel{$($\emph{nom de la règle}$)$}
	\UIC{\quad\emph{conclusion}\quad}
	\DP

\	
%\vspace{.5em}

%Signification :

\qquad
Si les prémisses sont valides, alors la conclusion est aussi valide.

\

\

\

Exemples de règles de \LK\ :

{
\center
%	\AXC{$\G,A \To \D$}
%	\AXC{$\G,B \To \D$}
%	\RightLabel{$(\lor L)$}
%	\BIC{$\G,A\lor B \To \D$}
%	\DP
	\AXC{$\G \To A,\D$}
	\AXC{$\G \To B,\D$}
	\RightLabel{$(\land R)$}
	\BIC{$\G \To A\land B,\D$}
	\DP
\qquad\qquad	
	\AXC{}
	\RightLabel{$(id)$}
	\UIC{$A \To A$}
	\DP
%\qquad\qquad
%	\AXC{}
%	\RightLabel{$(\bot L)$}
%	\UIC{$\G,\bot \To \D$}
%	\DP

}

%\vspace{1.5em}
%
%Ce sont des règles d'introduction : une constante ou un connecteur n'apparaissant pas dans les prémisses est introduit(e) dans la conclusion.
%
%\vspace{.2em}
%
%\qquad
%$\land R$ : introduction de $\land$ à droite du séquent
%
%\vspace{.2em}
%
%\qquad
%$\bot L$ : introduction de $\bot$ à gauche du séquent


}
\frame{
\frametitle{Familles de règles}

Identité : 
	\AXC{}
	\RightLabel{$(id)$}
	\UIC{$A \To A$}
	\DP
\hfill
Coupure : 
	\AXC{$\G \To A,\D$}
	\AXC{$\G',A \To \D'$}
	\RightLabel{$(cut)$}
	\BIC{$\G,\G' \To \D,\D'$}
	\DP







%\begin{tabular}{c|c}
%	Règles logiques & Règles structurelles \\[2em]
%	\etR & \contractionL\\[1.5em]
%	\fauxL & \exchangeR \\
%	une constante ou un connecteur n'apparaissant pas dans les prémisses est introduit(e) dans la conclusion &
%\end{tabular}


\def\vspaceBetweenRules{\vspace{.6em}}

\begin{columns}[t]

\begin{column}{.48\textwidth}
\center

Règles logiques

\vspace{1.5em}

	\AXC{$\G \To A,\D$}
	\AXC{$\G \To B,\D$}
	\RightLabel{$(\land R)$}
	\BIC{$\G \To A\land B,\D$}
	\DP

\vspaceBetweenRules

	\AXC{}
	\RightLabel{$(\bot L)$}
	\UIC{$\G,\bot \To \D$}
	\DP

\vspaceBetweenRules

	\AXC{$\G,A \To B,\D$}
	\RightLabel{$(\imp R)$}
	\UIC{$\G \To A\to B,\D$}
	\DP

\flushleft
%Une constante ou un connecteur n'apparaissant pas dans les prémisses est introduit(e) dans la conclusion.
Introduction dans la conclusion d'une constante ou d'un connecteur n'apparaissant pas dans les prémisses.

\end{column}


\vrule{}

\begin{column}{.48\textwidth}
\center

Règles structurelles

\vspace{1.5em}

	\AXC{$\G \To \D$}
	\RightLabel{$(weakening\ L)$}
	\UIC{$\G,A \To \D$}
	\DP

\vspaceBetweenRules

	\AXC{$\G \To A,A,\D$}
	\RightLabel{$(contraction\ R)$}
	\UIC{$\G \To A,\D$}
	\DP

\vspaceBetweenRules

	\AXC{$\G_{1},A,B,\G_{2} \To \D$}
	\RightLabel{$(exchange\ L)$}
	\UIC{$\G_{1},B,A,\G_{2} \To \D$}
	\DP

\flushleft
Modification du nombre d'occurrences ou déplacement de formules dont on ne connaît pas la structure.

\end{column}

\end{columns}





}
\frame{
%\frametitle{Prouvabilité}

Une \emph{preuve}, ou \emph{arbre de preuve}, est un arbre dont chaque n\oe ud est étiqueté par un séquent et une règle,
% de sorte que lorsqu'on considère les fils de ce n\oe ud, on obtient une application de la règle.
tel que les séquents associés à un n\oe ud et à ses fils forment une application de la règle associée au n\oe ud.



\center
	\AXC{$$}
	\RightLabel{$(id)$}
	\UIC{$A \To A$}
	\RightLabel{$(weakening\ L)$}
	\UIC{$A,B \To A$}
		\AXC{$$}
		\RightLabel{$(id)$}
		\UIC{$B \To B$}
		\RightLabel{$(weakening\ L)$}
		\UIC{$B,A \To A$}
		\RightLabel{$(exchange\ L)$}
		\UIC{$A,B \To A$}
	\RightLabel{$(\land R)$}
	\BIC{$A,B \To A\land B$}
	\DP

\vspace{.5em}

%\flushleft

\begin{df}
Un séquent est \textbf{prouvable dans un calcul} s'il existe un arbre de preuve dont la racine est étiquetée par ce séquent. On dit alors que l'arbre est une \textbf{preuve de ce séquent}.
\end{df}

\begin{prop}
Une formule $A$ est valide en logique classique si, et seulement si, le séquent $\; \To A$ est prouvable dans \LK.
\end{prop}


%Une \emph{preuve}, ou \emph{arbre de preuve}, est un arbre, dont les n\oe uds sont étiquetés par des séquents, tel que : pour tout n\oe ud étiqueté par $\s$, si ses fils sont étiquetés par $\s_{1}$, ... , $\s_{p}$ respectivement, alors
%	\AXC{$\s_{1}$}
%	\AXC{$...$}
%	\AXC{$\s_{p}$}
%	%\RightLabel{$(\land R)$}
%	\TIC{$\s$}
%	\DP
%est une application d'une règle.

%Une \emph{instance} d'une règle est l'application de cette règle à des séquents donnés
%%, et s'écrit sous la même forme que la règle 
%: par exemple
%	\AXC{$p,q \To r$}
%	\AXC{$p,q \To s$}
%	\RightLabel{$(\land R)$}
%	\BIC{$p,q \To r\land s$}
%	\DP
%
%\
%
%Une \emph{preuve}, ou \emph{arbre de preuve}, est un arbre dont les n\oe uds sont étiquetés par un séquent et une règle et ont la même arité que le nombre de prémisses de la règle, et tel que : pour tout n\oe ud de séquent $\s$ et de règle $\mathcal R$, si $\s_{1}$, ... , $\s_{p}$ sont les séquents associés à chacun de ses fils respectivement, alors
%	\AXC{$\s_{1}$}
%	\AXC{$...$}
%	\AXC{$\s_{p}$}
%	\RightLabel{$(\land R)$}
%	\TIC{$\s$}
%	\DP
%est une instance de $\mathcal R$. %Les feuilles d'un tel arbre sont les n\oe uds auxquels est associé un axiome.





}
\frame{
\frametitle{Calcul \LJ\ et logique intuitionniste}

On obtient le calcul \LJ\ à partir de \LK\ en se restreignant à des séquents avec exactement une formule à droite.

\begin{df}
Un \textbf{\emph{séquent}} de \LJ\ consiste en une liste de formules $\G$ et une formule $D$. On le note $\G \vdash D$. 
\end{df}

Un séquent $\G \To D$ correspond à la formule $\left(\bigwedge_{G\in\G}G\right)\to D$ en logique intuitionniste.

\

Les règles sont adaptées en conséquence :

\vspace{.5em}

\begin{tabular}{ccc}
	\AXC{$\G \To A,\D$}
	\AXC{$\G \To B,\D$}
	\RightLabel{$(\land R)$}
	\BIC{$\G \To A\land B,\D$}
	\DP
& \quad $\dashrightarrow$ \quad &
	\AXC{$\G \To A$}
	\AXC{$\G \To B$}
	\RightLabel{$(\land R)$}
	\BIC{$\G \To A\land B$}
	\DP
\\[1em]
%	\AXC{$\G \To A,\D$}
%	\AXC{$\G,B \To \D$}
%	\RightLabel{$(\imp L)$}
%	\BIC{$\G,A\to B \To \D$}
%	\DP
%& \quad $\dashrightarrow$ \quad &
%	\AXC{$\G \To A$}
%	\AXC{$\G,B \To D$}
%	\RightLabel{$(\imp L)$}
%	\BIC{$\G,A\to B \To D$}
%	\DP
%\\[1em]
	\AXC{$\G \To A,\D$}
	\AXC{$\G',A \To \D'$}
	\RightLabel{$(cut)$}
	\BIC{$\G,\G' \To \D,\D'$}
	\DP
& \quad $\dashrightarrow$ \quad &
	\AXC{$\G \To A$}
	\AXC{$\G',A \To D$}
	\RightLabel{$(cut)$}
	\BIC{$\G,\G' \To D$}
	\DP
\end{tabular}


}


\frame{
\frametitle{Calcul \LJ\ et logique intuitionniste}

Les règles structurelles à droite disparaissent :
	\AXC{$\G \To \D$}
	\RightLabel{$(weakening\ R)$}
	\UIC{$\G \To A,\D$}
	\DP

\flushright
	\AXC{$\G \To A,A,\D$}
	\RightLabel{$(contraction\ R)$}
	\UIC{$\G \To A,\D$}
	\DP
\qquad
	\AXC{$\G \To \D_{1},A,B,\D_{2}$}
	\RightLabel{$(exchange\ R)$}
	\UIC{$\G \To \D_{1},B,A,\D_{2}$}
	\DP

\

\flushleft
\begin{dfprop}
Une formule $A$ est \textbf{prouvable en logique intuitionniste} si, et seulement si, le séquent $\; \To A$ est prouvable dans \LJ.
\end{dfprop}

\

Cette restriction à des séquents avec exactement une formule à droite explique qu'il existe des formules vraies en logique classique mais non prouvables en logique intuitionniste, par exemple le principe du tiers exclu $A \lor \lnot A$ : pour prouver le séquent $\; \To A\lor \lnot A$ dans \LK, on passe par un séquent $\; \To A\,, \!\lnot A$ qui n'existe pas dans \LJ.


}
\frame{
\frametitle{\'Elimination de la coupure}

\begin{tabular}{lcc}
\hspace{-.6em}Règle de coupure : &
	\AXC{$\G \To A,\D$}
	\AXC{$\G',A \To \D'$}
	\RightLabel{$(cut)$}
	\BIC{$\G,\G' \To \D,\D'$}
	\DP
& dans \LK \\[1em]
&
	\AXC{$\G \To A$}
	\AXC{$\G',A \To D$}
	\RightLabel{$(cut)$}
	\BIC{$\G,\G' \To D$}
	\DP
& dans \LJ
\end{tabular}

\

Signification importante : si on prouve $A$, on peut ensuite se servir de $A$ comme hypothèse.


\begin{cadre}
Un calcul des séquents comportant une règle de coupure vérifie la propriété d'\textbf{élimination de la coupure} si, lorsqu'on enlève la règle de coupure, on obtient un calcul des séquents équivalent, c'est-à-dire que les séquents prouvables sont les mêmes.
\end{cadre}

\begin{theo}
\LK\ et \LJ\ vérifient la propriété d'élimination de la coupure.
\end{theo}


}
\frame{
\frametitle{\'Elimination de la coupure}

Formulation équivalente :
\begin{cadre}
%Un calcul des séquents comportant une règle de coupure vérifie la propriété d'\textbf{élimination de la coupure} si, pour tout arbre de preuve, il existe un arbre de preuve qui a la même conclusion (i.e. le même séquent étiquetant la racine) et dans lequel la règle de coupure n'apparaît pas.
Un calcul des séquents comportant une règle de coupure vérifie la propriété d'\textbf{élimination de la coupure} si, pour toute preuve d'un séquent, il existe une preuve du même séquent dans laquelle la règle de coupure n'apparaît pas.
\end{cadre}

Il existe des preuves constructives qui proposent un procédé précis pour transformer une preuve donnée d'un séquent en une preuve du même séquent sans la règle de coupure.

\vspace{.5em}

Relation binaire sur les preuves : $p \triangleright p'$ si le procédé permet de transformer $p$ en $p'$.

\vspace{.5em}

La clôture symétrique et transitive de $\triangleright$ définit une relation d'équivalence appelée \emph{équivalence selon le procédé d'élimination de la coupure}.
%On peut alors définir une relation d'équivalence, appelée \emph{équivalence selon le procédé d'élimination de la coupure}, en considérant la clôture symétrique et transitive de la relation : 



}
\frame{
\frametitle{Catégorie : définition}

\begin{df}
Une \textbf{\emph{catégorie}} consiste en des \textbf{objets} (notés $A$,$B$,...) et des \textbf{morphismes} (notés $f$,$g$,...), avec une loi binaire partielle $\circ$ sur les morphismes, tels que

\begin{itemize}
\item
à chaque morphisme $f$ est associé un couple d'objets $(A,B)$ ; \\on note $f:A\to B$.

\item
si $f:A\to B$ et $g:B\to C$, il existe un morphisme $g\circ f:A\to C$.

\item
pour tout $A$, il existe une \textbf{identité} $id_{A}:A\to A$ vérifiant $id_{A}\circ f=f$ si $f:B\to A$ et $g\circ id_{A}=g$ si $g:A\to B$.

\item
la loi $\circ$ est \textbf{associative} :
si $f:A\to B$ et $g:B\to C$ et $h:C\to D$, alors $h\circ(g\circ f) = (h\circ g)\circ f$.
\end{itemize}

\end{df}

Exemples :

\qquad objets : ensembles, morphismes : fonctions

\qquad objets : sommets, morphismes : arêtes d'un graphe orienté



}
\frame{
\frametitle{Preuves et catégorie}

Cadre : un calcul des séquents vérifiant la propriété d'élimination de la coupure, avec une preuve constructive définissant un procédé d'élimination de la coupure et donc une relation d'équivalence.

\

\`A chaque preuve $p$ on associe une \emph{dénotation} $[p]$ telle que, pour toutes preuves $p$ et $p'$ qui sont équivalentes selon le procédé d'élimination de la coupure, $[p]=[p']$. On associe aussi une dénotation $[A]$ à chaque formule $A$.

\

On définit alors une catégorie $\CProofs$ :
\begin{itemize}
\item
objets : les dénotations des formules

\item
morphismes : les dénotations des preuves de séquents avec exactement une formule de chaque côté. Si $p$ est une preuve de $A\To B$, alors $[p]:[A]\to [B]$.
\end{itemize}

}
\frame{
\frametitle{Preuves et catégorie}

On définit alors une catégorie $\CProofs$ :
\begin{itemize}
\item
objets : les dénotations des formules

\item
morphismes : les dénotations des preuves de séquents avec exactement une formule de chaque côté. Si $p$ est une preuve de $A\To B$, alors $[p]:[A]\to [B]$.


\item
%\begin{floatingfigure}[r]{0.4\textwidth}
%\centering
%	\AXC	{$p_{1}$}
%	\dottedLine
%	\UIC{$A\vdash B$}
%	\AXC	{$p_{2}$}
%	\dottedLine
%	\UIC{$B\vdash C$}
%	\RightLabel{$(cut)$}
%	\BIC{$A\vdash C$}
%	\noLine
%	\UIC{}
%	\noLine
%	\UIC{$p$}
%	\DP\\
%\end{floatingfigure}


composition $\circ$ sur les morphismes : si $p_{1}$ est une preuve de $A \To B$ et $p_{2}$ une preuve de $B \To C$, donc $[p_{1}]:[A]\to [B]$ et $[p_{2}]:[B]\to [C]$, alors on définit $[p_{2}]\circ[p_{1}]=[p]:[A]\to[C]$ où $p$ est la preuve de
$A \To C$ suivante :
\hspace{4em}
$p$\;:\qquad
	\AXC	{$p_{1}$}
	\dottedLine
	\UIC{$A\vdash B$}
	\AXC	{$p_{2}$}
	\dottedLine
	\UIC{$B\vdash C$}
	\RightLabel{$(cut)$}
	\BIC{$A\vdash C$}
	\DP
	
	
%\begin{columns}[t]
%\column[t]{.4\linewidth}
%\end{columns}

%
%}



\vspace{1em}

\item
identité sur $[A]$ : dénotation de
	\AXC	{}
	\RightLabel{$(id)$}
	\UIC{$A\vdash A$}
	\DP

\end{itemize}




}
\frame{
\frametitle{Preuves et catégorie}

associativité, propriétés de l'identité


}
\frame{
\frametitle{Tenseur et catégorie monoïdale ?}

sans donner le détail des définitions, dire qu'on veut des morphismes $\alpha$, $\lambda$, $\rho$ de type donné vérifiant certaines propriétés, et qu'on les obtient comme dénotations de preuves explicites









%%%%%%








}
\frame{
\frametitle{Algorithme de recherche de preuve}

Prouveur


}
\frame{
\frametitle{}

Règle de coupure

\

Règle de contraction


}
\frame{
\frametitle{}

Inversibilité

\

Localité



}
\frame{
\frametitle{\LSJ}

séquents

\

exemples de règles



}
\frame{
\frametitle{\LSJn}





}
\frame{
\frametitle{Priorités}




}
\frame{
\frametitle{Indexation}



}
\frame{
\frametitle{Efficacité 1}

ILTP, tableau avec quelques temps


}
\frame{
\frametitle{Efficacité 2}

SYJ209



}
\frame{
\frametitle{Langage \T}




}
\frame{
\frametitle{Compilation de fonctions adaptées à la formule}


}
\frame{
\frametitle{Différents prouveurs}

où mettre la structure du code avec le nombre de lignes


}
\frame{
\frametitle{Pistes d'amélioration}



}
\frame{
\frametitle{}

}
\end{document}

%%%%%%%%%%%%%%%
\section{Définitions}
\subsection{Alphabet gradué et termes}
\frame{

\begin{df}
Un \textbf{alphabet gradué} consiste en $\F$ un ensemble fini, et $Arit\acute{e}$ une application de $\F$ dans $\N$.
L'\textbf{arité} d'un élément $f\in\F$ est l'entier $Arit\acute{e}(f)$.
\end{df}
$\F_{p}$ : l'ensemble des éléments de $\F$ d'arité $p$

Un élément d'arité $0$, $1$, ... ,$p$ est appelé respectivement \textit{constante}, \textit{terme unaire}, ... , \textit{terme $p$-aire}.

\

\begin{df}
Soit $\F$ un alphabet gradué. On suppose que $\F$ contient au moins une constante.
L'ensemble $\TF$ des \textbf{termes} sur $\F$ est le plus petit ensemble contenant $\F_{0}$ et vérifiant :

pour tous $p\in\N^{*}$, $\: f\in\F_{p}$, $\: t_{1},...,t_{p}\in\TF$, $\; f(t_{1},...,t_{p})\in\TF$.
\end{df}








}\subsection{Automates d'arbres}
\frame{

\begin{df}
Un \textbf{automate d'arbres} finis (non déterministe) sur l'alphabet gradué $\F$ est un uplet $\A = (Q,\F,Q_{f},\Delta)$ avec $Q$ un ensemble d'états, $Q_{f}\subset Q$ un ensemble d'états finals, et $\Delta$ une fonction de transition i.e. un ensemble de règles de la forme $f(q_{1},...,q_{p}) \rightarrow q$ avec $q, q_{i} \in Q$ et $f \in \F_{p}$.
\end{df}

$\F'=\F \cup Q$ (on suppose $\F$ et $Q$ disjoints) avec $\forall q \in Q, Arit\acute{e}(q)=0$

\

Pour $t,t'\in\TFp$ : $\qquad t \rightarrow_{\A} t' \qquad$ si $t'$ s'obtient en rempla\c cant un sous-arbre $f(q_{1},...,q_{p})$ de $t$ par $q$ tel que la règle $f(q_{1},...,q_{p}) \rightarrow q$ est dans $\Delta$.

\

$\rightarrow_{\A}^{*}$ : clôture réflexive et transitive de $\rightarrow_{\A}$

\begin{cadre}
$t \in \TF$ \textbf{accepté par} $\A$ s'il existe $q\in Q_{f}$ tel que $t \rightarrow_{\A}^{*} q$
\end{cadre}

\

pas d'état initial : on commence aux constantes ($a \rightarrow q$ avec $a \in \F_{0}$)




}\frame{
\frametitle{Exemple}

$\F = \{ 1(0), 0(0), non(1), et(2), ou(2) \}$

\

$\A = (Q,\F,Q_{f},\Delta) \qquad Q=\{q_{0},q_{1}\} \qquad Q_{f}=\{q_{1}\}$

$\Delta = \{ \quad 0 \rightarrow q_{0} \:,\;  1 \rightarrow q_{1} \:,\;  non(q_{0}) \rightarrow q_{1} \:,\; non(q_{1}) \rightarrow q_{0} \:,$

$\quad 
et(q_{0},q_{0}) \rightarrow q_{0} \:,\;
et(q_{0},q_{1}) \rightarrow q_{0} \:,\;
et(q_{1},q_{0}) \rightarrow q_{0} \:,\;$

$\quad
et(q_{1},q_{1}) \rightarrow q_{1} \:,\;
ou(q_{0},q_{0}) \rightarrow q_{0} \:,\;
ou(q_{0},q_{1}) \rightarrow q_{1} \:,\;$

$\quad 
ou(q_{1},q_{0}) \rightarrow q_{1} \:,\;
ou(q_{1},q_{1}) \rightarrow q_{1}
\quad \}$

\

\def\DistanceInterNiveaux{1}
\def\DistanceInterFeuilles{1}
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-1)*\DistanceInterNiveaux}
\def\NiveauC{(-2)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
\def\arbreA{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$et$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$non$};
\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$0$};
\node (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$ou$};
\node (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {$1$};
\node (Rbb) at ({(2)*\InterFeuilles},{\NiveauC}) {$0$};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (R)--(Rb);
\draw (Rb)--(Rba);
\draw (Rb)--(Rbb);
\end{tikzpicture}
}
\def\arbreB{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$et$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$non$};
\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$q_{0}$};
\node (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$ou$};
\node (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {$q_{1}$};
\node (Rbb) at ({(2)*\InterFeuilles},{\NiveauC}) {$q_{0}$};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (R)--(Rb);
\draw (Rb)--(Rba);
\draw (Rb)--(Rbb);
\end{tikzpicture}
}
\def\arbreC{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$et$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$q_{1}$};
\node (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$q_{1}$};
\node (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {};
\draw (R)--(Ra);
\draw (R)--(Rb);
\end{tikzpicture}
}
\def\arbreD{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$q_{1}$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {};
\node (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {};
\end{tikzpicture}
}
\begin{tabular}{cccc}
   \arbreA & \arbreB & \arbreC & \arbreD \\
\end{tabular}



}\frame{

\begin{df}
Le \textbf{langage d'arbres reconnu} par l'automate d'arbres $\A$, noté $L(\A)$, est l'ensemble des termes de $\TF$ acceptés par $\A$.
\end{df}

\

On dit ``$\A$ reconnaît $L$'' pour $L=L(\A)$ (et pas seulement ``tout terme de $L$ est reconnu par $\A$'').

\

\begin{df}
Un langage d'arbres $L$ est \textbf{reconnaissable} s'il existe un automate d'arbres qui reconnaît $L$.
\end{df}




}\subsection{Lien avec les automates de mots}
\frame{

\frametitle{Lien avec les automates habituels (de mots)}

Le mot $abbab$ sur l'aphabet $\Sigma = \{ a,b \}$ peut être vu comme le terme $a(b(b(a(b(\#)))))$ sur $\F =  \{ a,b,\# \}$ avec $a$ et $b$ unaire et $\#$ constante, ou plutôt $b(a(b(b(a(\#)))))$ (à l'envers) pour ce qui suit.

\

À un automate de mots $(Q,\Sigma,Q_{i},Q_{f},\Delta_{0})$ on peut associer l'automate d'arbres $(Q,\F,Q_{f},\Delta)$ suivant :

$\F = \Sigma \cup  \{ \# \}$ où les éléments de $\Sigma$ sont d'arité 1 et $\#$ d'arité $0$ ;

$\Delta$ obtenu à partir de $\Delta_{0}$ en transformant $(q,a) \rightarrow q'$ en $a(q) \rightarrow q'$, et en ajoutant $\# \rightarrow q$ pour chaque $q \in Q_{i}$ .



%}\frame{
%\frametitle{Et les $\epsi$-transitions ?}
%
%\begin{theo}
%Soit un automate d'arbres $\A = (Q,\F,Q_{f},\Delta)$ avec des $\epsi$-transitions ($\Delta$ contient des règles de la forme $q \rightarrow^{\epsi} q',\quad q,q' \in Q$), il existe un automate d'arbres $\A'$ sans $\epsi$-transition tel que $L(\A)=L(\A')$.
%\end{theo}
%
%\begin{dem}
%$\A' = (Q,\F,Q_{f},\Delta')$, où $\Delta'$ contient les éléments de $\Delta$ qui ne sont pas des $\epsi$-transitions, ainsi que tous les $f(q_{1},...,q_{p}) \rightarrow q'$ tels qu'il existe $q$ tel que $f(q_{1},...,q_{p}) \rightarrow q \in \Delta$ et $q \rightarrow^{\epsi} q' \in \Delta$
%\end{dem}



%%%



}\section{Quelques propriétés}
\subsection{Automates déterministes}
\frame{
\frametitle{Automates déterministes}

Automate d'arbres déterministe : définition habituelle (maximum une transition dans $\Delta$ pour chaque membre gauche).

\begin{theo}
Soit $L$ un langage d'arbres reconnaissable, alors il existe $\A$ automate d'arbres déterministe tel que $L=L(\A)$.
\end{theo}

Preuve similaire à celle pour les automates de mots

\

$\A = (Q,\F,Q_{f},\Delta)$ reconnaissant $L$, on construit $\A' = (Q',\F,Q_{f}',\Delta')$ où :

$Q'=\mathcal{P}(Q)$

$Q_{f}'=\{ s \in Q', s \cap Q_{f} \neq \emptyset \}$

$\Delta' = \{ \; f(s_{1},...,s_{p}) \rightarrow s \;|$

$\qquad\qquad\quad s = \{ \; q \; | \quad \exists q_{1} \in s_{1}, \;...\; ,\: \exists q_{p} \in s_{p}, \; f(q_{1},...,q_{p}) \rightarrow q \in \Delta \} \quad \}$

\

preuve que $\A'$ convient : induction



%


}\subsection{Propriétés de clôture}
\frame{
\frametitle{Propriétés de clôture}

\begin{theo}
La classe des langages reconnaissables par automate d'arbres est close par union, complémentaire, intersection.
\end{theo}

Preuves similaires à celle pour les automates de mots

\

\begin{itemize}
    \item union : $\A_{1} = (Q_{1},\F,Q_{f1},\Delta_{1}), \A_{2} = (Q_{2},\F,Q_{f2},\Delta_{2})$
    
    $\A = (Q_{1}\sqcup Q_{2},\F,Q_{f1}\sqcup Q_{f2},\Delta_{1}\sqcup\Delta_{2})$
    
    \
    
    \item complémentaire : $\A = (Q,\F,Q_{f},\Delta)$ \underline{déterministe complet}
    
    $Q'_{f}=Q\backslash Q_{f}$
        
    \
    
    \item intersection : union + complémentaire
\end{itemize}


%


}\subsection{Lemme de pompage}
\frame{
\frametitle{Lemme de pompage}

\begin{df}
Soit $\F$ un alphabet gradué. Soit $x$ un symbole de variable ($x \notin \F$). On appellera \textbf{contexte} un élément de $T(\F \cup \{ x \})$ (avec $x$ d'arité $0$) dans lequel $x$ apparaît exactement une fois.

On appelle \textbf{contexte trivial} le contexte $x$.
\end{df}

$C$ un contexte, $t \in T(\F \cup \{ x \})$, on note $C[t]=C\{x\leftarrow t\} \in T(\F \cup \{ x \})$.

$t \in \TF \Rightarrow C[t] \in \TF\;\,$ ; $\;t \text{ contexte} \Rightarrow C[t] \text{ contexte}$.

\

$C$ un contexte, on pose : $C^{0}=x$ %$C^{1}=C$, 
et pour $n\in\N$, $C^{n+1}=C^{n}[C]$ %(en particulier $C^{1}=C$)



}\frame{
\frametitle{Lemme de pompage}

\begin{theo}
Soit $L$ un langage d'arbres reconnaissable sur $\F$, alors il existe $k \in \N$ tel que pour tout terme $t\in L$ de hauteur $>k$, il existe des contextes $C$ et $D$ avec $D$ non trivial et $s \in \TF$ tels que 
$$t=C[D[s]] \quad\text{et}\quad \forall n \in\N,\: C[D^{n}[s]] \in L$$
\end{theo}


%




}\subsection{Complexité}
\frame{
\frametitle{Complexité}

$\A = (Q,\F,Q_{f},\Delta)$

taille de la transition $f(q_{1},...,q_{p}) \rightarrow q$   :   $Arit\acute{e}(f)+2$

taille de $\A$   :   $||\A|| = \card Q + \sum_{f(q_{1},...,q_{p}) \rightarrow q \in \Delta}(Arit\acute{e}(f)+2)$

\

taille $||t||$ d'un terme $t$ : ``nombre de noeuds''

\

savoir si un terme $t$ est reconnu par un automate $\A$ :

\begin{tabular}{clc}
\quad - & $\A$ déterministe : &\quad$O(||t||+||\A||)$ \\
\quad - & $\A$ non déterministe : &\quad$O(||t||\times||\A||)$
\end{tabular}




%%%



}\section{Automates d'arbres ``top-down''}
\subsection{Définition}
\frame{


\begin{df}
Un \textbf{automate d'arbres ``top-down''} (non déterministe) sur un alphabet gradué $\F$ est un uplet $\A = (Q,\F,Q_{i},\Delta)$ avec $Q$ un ensemble d'états, $Q_{i}\subset Q$ un ensemble d'états initiaux, et $\Delta$ une fonction de transition i.e. un ensemble de règles de la forme $q(f(x_{1},...,x_{p})) \rightarrow f(q_{1}(x_{1}),...,q_{p}(x_{p}))$ avec $q, q_{i} \in Q$ et $f \in \F_{p}$ (les $x_{i}$ sont des symboles de variables).% ; de plus on impose que pour $a \in \F_{0}$, les transitions faisant intervenir $a$ sont de type $q(a) \rightarrow a$.
\end{df}

$\F'=\F \cup Q$ (on suppose $\F$ et $Q$ disjoints) avec $\forall q \in Q, Arit\acute{e}(q)=1$

\

Pour $t,t'\in\TFp$ : $\qquad t \rightarrow_{\A} t' \qquad$ si $t'$ s'obtient en rempla\c cant un sous-arbre $q(f(t_{1},...,t_{p}))$ de $t$ par $f(q_{1}(t_{1}),...,q_{p}(t_{p}))$ tel que la règle $q(f(x_{1},...,x_{p})) \rightarrow f(q_{1}(x_{1}),...,q_{p}(x_{p}))$ est dans $\Delta$.

\

$\rightarrow_{\A}^{*}$ : clôture réflexive et transitive de $\rightarrow_{\A}$

\begin{cadre}
$t \in \TF$ \textbf{accepté par $\A$} s'il existe $q\in Q_{i}$ tel que $q(t) \rightarrow_{\A}^{*} t$
\end{cadre}

pour $a \in \F_{0}$, transitions de type $q(a) \rightarrow a$



}\frame{
\frametitle{Exemple}

$\F = \{ 1(0), 0(0), non(1), et(2), ou(2) \}$

\

$\A = (Q,\F,Q_{i},\Delta) \qquad Q=\{q_{1},q_{2}\} \qquad Q_{i}=\{q_{1}\}$

$\Delta = \{ \; q_{0}(0) \rightarrow 0 \:,\;  q_{1}(1) \rightarrow 1 \:,\;  q_{0}(non(x)) \rightarrow q_{1}(x) \:,\;
q_{1}(non(x)) \rightarrow q_{0}(x),$

$\quad  q_{0}(and(x,y)) \rightarrow et(q_{0}(x),q_{0}(y)) \:,$

$\quad q_{0}(and(x,y)) \rightarrow et(q_{0}(x),q_{1}(y)) \:,$

$\quad  q_{0}(and(x,y)) \rightarrow et(q_{1}(x),q_{0}(y)) \:,$

$\quad  q_{1}(and(x,y)) \rightarrow et(q_{1}(x),q_{1}(y)) \:,$

$\quad  q_{0}(or(x,y)) \rightarrow ou(q_{0}(x),q_{0}(y)) \:,$

$\quad q_{1}(or(x,y)) \rightarrow ou(q_{0}(x),q_{1}(y)) \:,$

$\quad  q_{1}(or(x,y)) \rightarrow ou(q_{1}(x),q_{0}(y)) \:,$

$\quad  q_{1}(or(x,y)) \rightarrow ou(q_{1}(x),q_{1}(y)) \quad \}$



}\frame{
\frametitle{Exemple}

$\F = \{ 1(0), 0(0), non(1), et(2), ou(2) \}$

\

$\A = (Q,\F,Q_{i},\Delta) \qquad Q=\{q_{0},q_{1}\} \qquad Q_{i}=\{q_{1}\}$

$\Delta = \{ \quad q_{1}(et(x,y)) \rightarrow ou(q_{1}(x),q_{1}(y))\:,\; q_{1}(non(x)) \rightarrow q_{0}(x)\:,$

$\quad q_{1}(ou(x,y)) \rightarrow ou(q_{1}(x),q_{0}(y)) \:,\; q_{0}(0) \rightarrow 0 \:,\;  q_{1}(1) \rightarrow 1 \:,\; \text{etc.} \quad \}$

\

\def\DistanceInterNiveaux{1}
\def\DistanceInterFeuilles{1}
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-1)*\DistanceInterNiveaux}
\def\NiveauC{(-2)*\DistanceInterNiveaux}
\def\NiveauD{(-3)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
\def\arbreA{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$q_1$};
\node (Ra) at ({(1)*\InterFeuilles},{\NiveauB}) {$et$};
\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$non$};
\node (Raaa) at ({(0)*\InterFeuilles},{\NiveauD}) {$0$};
\node (Rab) at ({(1.5)*\InterFeuilles},{\NiveauC}) {$ou$};
\node (Raba) at ({(1)*\InterFeuilles},{\NiveauD}) {$1$};
\node (Rbab) at ({(2)*\InterFeuilles},{\NiveauD}) {$0$};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (Raa)--(Raaa);
\draw (Ra)--(Rab);
\draw (Rab)--(Raba);
\draw (Rab)--(Rbab);
\end{tikzpicture}
}
\def\arbreB{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$et$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$q_1$};
\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$non$};
\node (Raaa) at ({(0)*\InterFeuilles},{\NiveauD}) {$0$};
\node (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$q_1$};
\node (Rba) at ({(1.5)*\InterFeuilles},{\NiveauC}) {$ou$};
\node (Rbaa) at ({(1)*\InterFeuilles},{\NiveauD}) {$1$};
\node (Rbab) at ({(2)*\InterFeuilles},{\NiveauD}) {$0$};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (Raa)--(Raaa);
\draw (R)--(Rb);
\draw (Rb)--(Rba);
\draw (Rba)--(Rbaa);
\draw (Rba)--(Rbab);
\end{tikzpicture}
}
\def\arbreC{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$et$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$non$};
\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$q_0$};
\node (Raaa) at ({(0)*\InterFeuilles},{\NiveauD}) {$0$};
\node (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$ou$};
\node (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {$q_1$};
\node (Rbaa) at ({(1)*\InterFeuilles},{\NiveauD}) {$1$};
\node (Rbb) at ({(2)*\InterFeuilles},{\NiveauC}) {$q_0$};
\node (Rbba) at ({(2)*\InterFeuilles},{\NiveauD}) {$0$};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (Raa)--(Raaa);
\draw (R)--(Rb);
\draw (Rb)--(Rba);
\draw (Rba)--(Rbaa);
\draw (Rb)--(Rbb);
\draw (Rbb)--(Rbba);
\end{tikzpicture}
}
\def\arbreD{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$et$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$non$};
\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$0$};
\node (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$ou$};
\node (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {$1$};
\node (Rbb) at ({(2)*\InterFeuilles},{\NiveauC}) {$0$};
\node () at ({(2)*\InterFeuilles},{\NiveauD}) {};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (R)--(Rb);
\draw (Rb)--(Rba);
\draw (Rb)--(Rbb);
\end{tikzpicture}
}
\begin{tabular}{cccc}
   \arbreA & \arbreB & \arbreC & \arbreD \\
\end{tabular}

\

$\exists q\in Q_{i}, q(t) \rightarrow_{\A}^{*} t$




}\subsection{Équivalence}
\frame{



\begin{theo}
Les automates d'arbres ``down-top'' et ``top-down'' ont le même pouvoir expressif, i.e. tout langage reconnaissable par un automate d'un type est reconnaissable par un automate de l'autre type.
\end{theo}





}\frame{

\def\DistanceInterNiveaux{1}
\def\DistanceInterFeuilles{1}
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-1)*\DistanceInterNiveaux}
\def\NiveauC{(-2)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
\def\arbreA{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuilles},{\NiveauA}) {$et$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$non$};
\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$0$};
\node (Rb) at ({(1.5)*\InterFeuilles},{\NiveauB}) {$ou$};
\node (Rba) at ({(1)*\InterFeuilles},{\NiveauC}) {$1$};
\node (Rbb) at ({(2)*\InterFeuilles},{\NiveauC}) {$0$};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (R)--(Rb);
\draw (Rb)--(Rba);
\draw (Rb)--(Rbb);
\end{tikzpicture}
}
\def\InterFeuillesB{(2)*\DistanceInterFeuilles}
\def\arbreB{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(1)*\InterFeuillesB},{\NiveauA}) {\textcolor{orange}{$\epsi$}   $et$   \textcolor{blue}{$q_{1}$}};
\node (Ra) at ({(0)*\InterFeuillesB},{\NiveauB}) {\textcolor{orange}{$0$}   $non$   \textcolor{blue}{$q_{1}$}};
\node (Raa) at ({(0)*\InterFeuillesB},{\NiveauC}) {\textcolor{orange}{$00$}   $0$   \textcolor{blue}{$q_{0}$}};
\node (Rb) at ({(1.5)*\InterFeuillesB},{\NiveauB}) {\textcolor{orange}{$1$}   $ou$   \textcolor{blue}{$q_{1}$}};
\node (Rba) at ({(1)*\InterFeuillesB},{\NiveauC}) {\textcolor{orange}{$10$}   $1$   \textcolor{blue}{$q_{1}$}};
\node (Rbb) at ({(2)*\InterFeuillesB},{\NiveauC}) {\textcolor{orange}{$11$}   $0$   \textcolor{blue}{$q_{0}$}};
\draw (R)--(Ra);
\draw (Ra)--(Raa);
\draw (R)--(Rb);
\draw (Rb)--(Rba);
\draw (Rb)--(Rbb);
\end{tikzpicture}
}



$\F = \{ 1(0), 0(0), non(1), et(2), ou(2) \}$

\

$\A_{d-t} = (Q,\F,Q_{f},\Delta_{d-t}) \qquad \A_{t-d} = (Q,\F,Q_{i},\Delta_{t-d})$

$Q=\{q_{0},q_{1}\} \qquad Q_{f}=Q_{i}=\{q_{1}\}$

%$\Delta_{d-t} = \{ \; 0 \rightarrow q_{0} \:,\;  1 \rightarrow q_{1} \:,\;  not(q_{0}) \rightarrow q_{1} \:,\; and(q_{0},q_{0}) \rightarrow q_{0} \:,\; \text{etc.} \; \}$

%$\A_{t-d} = (Q,\F,Q_{i},\Delta_{t-d}) \qquad Q=\{q_{1},q_{2}\} \qquad Q_{i}=\{q_{1}\}$

%$\Delta_{t-d} = \{ \; q_{0}(0) \rightarrow 0 \:,\;  q_{1}(1) \rightarrow 1 \:,\;  q_{0}(not(x)) \rightarrow q_{1}(x) \:,\; $
%q_{1}(not(x)) \rightarrow q_{0}(x)$

%$\quad  q_{0}(and(x,y)) \rightarrow and(q_{0}(x),q_{0}(y)) 
%\:,$
%
%$\quad q_{0}(and(x,y)) \rightarrow and(q_{0}(x),q_{1}(y)) \:,$
%
%$\quad  q_{0}(and(x,y)) \rightarrow and(q_{1}(x),q_{0}(y)) 
%\:,\; \text{etc.} \; \}$

\

\begin{tabular}{cc}
   \arbreA & \arbreB \\
\end{tabular}

\

\textbf{arbre} : une fonction $tree : \N^{*} \rightarrow \F$

reconnaissable s'il existe $run : Pos(t) \rightarrow Q$ 

si $tree(pos)=f(t_{1},...,t_{p})$ \quad:\quad $q=run(pos),q_{i}=run(pos.i)$

\quad$f(q_{1},...,q_{p}) \rightarrow q \in \Delta_{d-t}$

\quad$q(f(x_{1},...,x_{p})) \rightarrow f(q_{1}(x_{1}),...,q_{p}(x_{p})) \in \Delta_{t-d}$






}\subsection{Non-équivalence : les automates déterministes}
\frame{

\def\DistanceInterNiveaux{1}
\def\DistanceInterFeuilles{1}
\def\NiveauA{(-0)*\DistanceInterNiveaux}
\def\NiveauB{(-1)*\DistanceInterNiveaux}
\def\InterFeuilles{(1)*\DistanceInterFeuilles}
\def\arbreA{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(0.5)*\InterFeuilles},{\NiveauA}) {$ou$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$0$};
\node (Rb) at ({(1)*\InterFeuilles},{\NiveauB}) {$1$};
\draw (R)--(Ra);
\draw (R)--(Rb);
\end{tikzpicture}
}
\def\arbreB{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(0.5)*\InterFeuilles},{\NiveauA}) {$ou$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$1$};
\node (Rb) at ({(1)*\InterFeuilles},{\NiveauB}) {$0$};
\draw (R)--(Ra);
\draw (R)--(Rb);
\end{tikzpicture}
}
\def\arbreC{
\begin{tikzpicture}[xscale=1,yscale=1]
\node (R) at ({(0.5)*\InterFeuilles},{\NiveauA}) {$ou$};
\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$0$};
\node (Rb) at ({(1)*\InterFeuilles},{\NiveauB}) {$0$};
\draw (R)--(Ra);
\draw (R)--(Rb);
\end{tikzpicture}
}

\begin{theo}
Les automates ``top-down'' déterministes sont strictement moins expressifs que les automates ``top-down'' non déterministes (qui sont équivalents aux automates ``down-top'' non déterministes comme déterministes) ; i.e. il existe des langages reconnaissables par automate ``top-down'' non déterministe mais pas par automate ``down-top'' déterministe.
\end{theo}

\

Par exemple $\F = \{ 1(0), 0(0), non(1), et(2), ou(2) \} \; \longrightarrow \; L$ habituel

par l'absurde : $\A = (Q,\F,q_{i},\Delta)$ déterministe reconnaissant $L$

\

$q_{i}(ou(x,y)) \rightarrow ou(q(x),q'(y)) \in \Delta$

\

\begin{tabular}{ccc}
   \arbreA & \arbreB & \qquad\qquad\qquad\arbreC \\ 
   $q(0)\rightarrow 0 \in \Delta$ & $q'(0)\rightarrow 0 \in \Delta$ &
\end{tabular}

\





%}\frame{
%
%\begin{center}
%\begin{tikzpicture}[xscale=1,yscale=1]
%% Styles (MODIFIABLES)
%\tikzstyle{fleche}=[->,>=latex,thick]
%\tikzstyle{noeud}=[fill=yellow,circle,draw]
%\tikzstyle{feuille}=[fill=yellow,circle,draw]
%% Dimensions (MODIFIABLES)
%\def\DistanceInterNiveaux{1}
%\def\DistanceInterFeuilles{1}
%% Dimensions calculées (NON MODIFIABLES)
%\def\NiveauA{(-0)*\DistanceInterNiveaux}
%\def\NiveauB{(-1)*\DistanceInterNiveaux}
%\def\NiveauC{(-2)*\DistanceInterNiveaux}
%\def\InterFeuilles{(1)*\DistanceInterFeuilles}
%% Noeuds (MODIFIABLES : Styles et Coefficients d'InterFeuilles)
%\node (R) at ({(0.5)*\InterFeuilles},{\NiveauA}) {$f$};
%\node (Ra) at ({(0)*\InterFeuilles},{\NiveauB}) {$g$};
%\node (Raa) at ({(0)*\InterFeuilles},{\NiveauC}) {$a$};
%\node (Rb) at ({(1)*\InterFeuilles},{\NiveauB}) {$a$};
%% Arcs (MODIFIABLES : Styles)
%\draw (R)--(Ra);
%\draw (Ra)--(Raa);
%\draw (R)--(Rb);
%\end{tikzpicture}
%\end{center}
%%:-+-+-+-+- Fin






}\section*{Conclusion}
\frame{
\frametitle{Conclusion}

Beaucoup d'autres propriétés des automates qu'on connaît (par exemple Myhill-Nerode).

Des spécificités comme l'interaction avec les morphismes d'arbres.

Grammaires d'arbres...



\

Lien important avec la logique

\

\

\

\

\

Bibliographie :

H. Comon, Florent Jacquemard, M. Dauchet, R. Gilleron, D. Lugiez, C. L\"oding, S. Tison, M. Tommasi,

\quad\textit{Tree Automata Techniques and Applications}, chapitre 1




}\end{document}