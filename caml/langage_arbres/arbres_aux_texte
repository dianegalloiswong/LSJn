
let rm arg =
  match arg with <x,l> =>
  match l with <h,t> =>
  if h=x then t else <h,call rm <x,t>>

let mem arg =
  match arg with <x,l> =>
  if isnull(l) then 0 else
    match l with <hd,tl> =>
    if hd=x then 1 else call mem <x,tl>

let mem_inf arg =
  match arg with <arg1,l> =>
  if isnull(l) then 0 else
    match arg1 with <n,x> =>
    match l with <hd,tl> =>
    match hd with <i,y> =>
    if (i<=n && y=x) then 1 else call mem_inf <arg1,tl>

let n_of_seq seq =
  match seq with <formules,reste> =>
  match reste with <classes,infos> =>
  match infos with <n,axiomes> =>
  n

let rm_ax seq =
  match seq with <formules,reste> =>
  match reste with <classes,infos> =>
  match infos with <n,axiomes> =>
  <formules, <classes, <n, <0,0> > > >

let set_fauxL seq =
  match seq with <formules,reste> =>
  match reste with <classes,infos> =>
  match infos with <n,axiomes> =>
  match axiomes with <fauxL,id> =>
  <formules, <classes, <n, <1,id> > > >

let set_id seq =
  match seq with <formules,reste> =>
  match reste with <classes,infos> =>
  match infos with <n,axiomes> =>
  match axiomes with <fauxL,id> =>
  <formules, <classes, <n, <fauxL,1> > > >



let add_cl_g arg =
  match arg with <c,seq> =>
  match seq with <formules,reste> =>
  match reste with <classes,infos> =>
  match classes with <CG,CD> =>
  let CG = <c,CG> in
  let seq = <formules, < <CG,CD>, infos> > in

  match c with <i,cl> =>
  match infos with <n,axiomes> =>
  let seq = if i<=n && cl=0 then set_fauxL seq else seq in
  let seq = if i<=n && call mem <<n,cl>,CD> then set_id seq else seq in
  seq


let add_g arg =
  match arg with <arg1,seq> =>
  match arg1 with <c,cl> =>
  match c with <i,a> =>
  match seq with <formules,reste> =>
  match formules with <G,D> =>
  let G = <c,G> in
  let seq = <<G,D>,reste> in
  add_cl_g <<i,cl>,seq>





