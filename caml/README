
à faire : rétablir Seq.print et Seq.fold_vars, preuves et c-m avec le prouveur simple


ajout d'un prouveur utilisant le langage "trees" terminé. On l'utilise en donnant le flag -trees
(les fichiers dans ce langage ont pour l'instant l'extension .ml pour la coloration, mais sont situés exclusivement dans code_trees_fixe et code_trees_genere)
La partie "Description des fichiers" du README n'est pas à jour.

				caml		trees

SYN				.005s		1.2s
Problems/SYJ/SYJ201+1.002.p	.04s		14s
Problems/SYJ/SYJ201+1.003.p	1.7s		>1min
	caml : 2971326 appels à prouvable. trees en voit 102980 en 30s.
Problems/temoin_se_trompe.p	10E-5s		.008s
Problems/SYJ/SYJ204+1.009.p	.04s		>2min
Problems/SYJ/SYJ204+1.006.p	.01s		6.6s
pigeonhole 3 2			.02s		.0002s
	(dans les 2 cas 78 appels prouvable)





tests avec les 4 prouveurs
-ph 4 3 Problems/SYJ/SYJ201+1.002.p Problems/SYJ/SYJ204+1.006.p
results0.txt







--------

Usage

Les arguments déterminent des formules et résultas attendus correspondants.
Par défaut : pour chaque formule on imprime le nom de fichier éventuel, puis le temps mis à décider si elle est prouvable.
Dans tous les cas, si on a déterminé si une formule est prouvable, on compare le résultat obtenu avec celui attendu et s'ils sont différents on le signale.

-indexation : affiche la formule et l'indexation (ne lance pas de recherche de preuve)
-trees : utilise le prouveur "trees"
Par défaut : utilise le prouveur intégralement en caml

arguments :
	nom de fichier en .p avec la syntaxe des tests d'ILTP : en extrait directement une formule et le résultat attendu
	nom de répertoire : cherche récursivement les fichier en .p et fait la même chose
	-liste-courte : les formules à traiter sont quelques formules très courtes écrites à la main
	-liste : de même avec en plus des formules un tout petit peu plus longues
	-ph <int> <int> : la formule à traiter est le principe du pigeonnier avec les arguments donnés
	-eqb <int> : la formule à traiter est (x1 <-> x2) | ... | (x(n-1) <-> xn) | (xn <-> x1)

options :
	-f : affiche la formule
	-rep : affiche le résultat obtenu ("vrai" ou "faux")
	-rien-afficher : ne rien afficher sauf le temps total (mais comme toujours, si on obtient un résultat faux, on le signale quand même)
	-notime : ne pas chronométrer
	-stop <flottant> : arrête de chercher une preuve si le temps donné par l'argument en secondes est écoulé (coûteux en appels système)
Il manque les options pour afficher preuve ou contre-modèle. Et j'aimerais à un moment en remettre une pour traiter la logique classique : ce n'est pas intéressant niveau efficacité mais ça m'a plusieurs fois permis de repérer des bugs.



--------

Description des fichiers


Lorsqu'on dit que nom.ml fait quelque chose, cela sous-entend le cas échéant la fonction Nom.main


analyseur :

	lexer.mll, parser.mly, syntaxe_fichier.mli : ce à quoi on s'attend

	exec_fichier.ml : prend un nom de fichier, parse le fichier et lance Exec_formule.main sur la formule obtenue (en précisant aussi les résultats attendus)




prouveur :

	def.mli : la structure des formules
	global_ref.ml : les références de tableau sf (le graphe des sous-formules), classe et priorite, remplies par les fichier du dossier "indexation" et utilisées à divers endroits

	indexation :
		init_sf_classe : initialise Global_ref.sf et Global_ref.classe à partir de la formule donnée en argument
		init_priorite : initialise Global_ref.priorite

	prouveur.ml : décide si une formule est prouvable. C'est ici qu'on appelle les fonctions d'initialisation, puis stratégie/prouvable.ml.

	stratégie/prouvable.ml : exécute l'algorithme de recherche de preuve en utilisant les fonctions d'effet_regle_sur_sequent.ml

	preuve_contre_modele :
		les structures de preuve et contre-modèle et un type Rep.t qui peut être l'une ou l'autre, avec des fonctions pour les manipuler destinées à prouveur.ml. Ne contient que des fichiers inutilisés pour le moment (dont certains incomplets), car retenir toutes ces informations était trop coûteux. Il faudra que j'essaie de retenir un minimum d'information pour pouvoir les reconstruire à la demande.

	sequent :

		seq.ml : définit le séquent et contient les fonctions qui agissent dessus. Plusieurs champs du séquents contiennent des structures définies dans dans structures.

		effet_regle_sur_sequent.ml : pour chaque prémisse de chaque règle, contient une fonction qui transforme la conclusion en cette prémisse, et une qui fait la transformation inverse, en utilisant seq.ml.

		structures :
			Définit et manipule les structures utilisées dans les champs du séquent.

			tableau_priorite.ml : contient un foncteur qui fabrique un tableau de 7 cases contenant la structure donnée en argument, destiné à représenter les ensembles "gamma" et "delta" du séquent en classant les formules par priorité.

			tableau_classe.ml : contient un foncteur qui fabrique un tableau de la structure donnée en argument, avec autant de cases que de classes, destiné à retenir quelles classes sont présentes dans le séquent avec quels indices, afin de tester rapidement si on peut appliquer l'axiome "Id".

			case_priorite.ml et case_classe.ml : à partir des structures de données de indiceXsflist_list.ml et indiceXoccurrences_list.ml, fabriquent les modules qui seront donnés en argument aux foncteurs ci-dessus, en distinguant ceux destinés à représenter la partie gauche ou droite du séquent : on garde les fonctions en "_inf" (comme : on s'intéresse uniquement aux indices inférieurs à l'indice n du séquent lui-même, n étant donné en argument) pour la partie gauche, et en "_eq" (idem pour les indices égaux à n) pour la partie droite.

			indiceXsflist_list.ml : représente un ensemble de couples indice * (numéro de sous-formule) par une liste, triée par indices décroissants, de couples indice * (liste des numéros de sous-formule apparaissant avec cet indice), telle qu'il y a maximum un tel couple par indice et que s'il y en a un, la liste dedans est non vide. Utilisé pour "gamma" et "delta" (dans les cases du tableau indexé par les priorités).

			indiceXoccurrences_list.ml : représente un multiensemble d'indices par une liste de couples indice * (nombre d'occurrences de cet indice), triée par indices décroissants. Il y a maximum un couple par indice et s'il y en a un, le nombre d'occurrences est strictement positif. Utilisé pour retenir quelles classes sont présentes avec quels indices (dans les cases du tableau indexé par les classes).




sortie : contient les fichiers d'impression et de choix de ce qu'on imprime (je ne sais pas comment l'appeler...)

	exec_formule.ml : prend une formule et applique ce qui est indiqué par les options : l'imprime ou imprime les tableaux d'indexation ou applique Prouveur.main et imprime le résultat...
	main.ml : le fichier lancé à l'exécution. Parse les options et lance Analyseur.main sur des noms de fichiers ou directement Exec_formule.main sur des formules
	options.ml : contient les références correspondant aux options
	time.ml : contient tout ce qui permet de chronométrer
	to_string.ml : convertit différents type de données en chaînes de caractères







test_recherche_compilee : simulation de recherche de preuve où les fonctions de transformation du séquent par les règles sont compilées à part : ici ces fonctions sont précalculées et stockées dans un tableau. 
Ce n'est pas toujours facile de comparer à l'autre implémentation car je ne traite pas les "implique" dans le même ordre donc il y a parfois des écarts violents dans les deux sens dus à la chance de tomber rapidement sur le bon. Néanmoins dans certains cas où le nombre d'appels à "prouvable" est similaire, c'est 1,5 à 2 fois plus long.
(flag -comp)






